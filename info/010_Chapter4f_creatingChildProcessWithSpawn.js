/*
- In the last lesson we used the execute function off of the child process module. In this lesson we're going to take a look at the spawn function, and also contrast the difference between these functions. Let's go ahead and take a look at our files. So in our files system under the Start folder, you'll notice that we have two JavaScript files now. One is call spawn.js, that's an empty JavaScript file, and the other one is alwaysTalking. Let's take a look at alwaysTalking really quick. So alwaysTalking, in this JavaScript file we just have an array of sayings that we declare here on line 1.

And then on line 11 we are creating an interval, so every second we are going to randomly write one of these sayings to the standard output object. So on line 12 we get a random index that is no greater than the length of the sayings array, and then on line 13 we use that random index to randomly select one of the sayings, and using the stdout object we will write that saying along with a new line. On line 16 we wired up a listener on the standard input object to listen for a data event.

So whenever data is sent to this module via standard input, the callback function will fire and we will see the data there. On line 17 in the console log we will just log the data that comes into this function, and then we will clear the interval, and then on line 19 we will exit the process. So we will stop the sayings from happening and also exit this process. Let's take a look at this file. So let's go ahead and node alwaystalking, and we can see that we see a bunch of Ben Franklin quotes every second.

So this is an ongoing file. All of this data is being passed to the standard output object, that's why we're able to see it here on the terminal. As you notice this is a large amount of output. The longer we wait, we're going to get more output. Plus this process is ongoing, it doesn't end. It won't end until we send it some data, so I'm going to send it a stop command. So sending it stop causes the standard input data received message to get displayed, and we have the stop command, that's the data that was received, and then it also calls the application to exit.

So this is a large bit of data, and it also is a long running process. So the difference between spawn and execute is spawn is made for processes like this, where execute was made for asynchronously synchronous processes, meaning that if I do a directory listing we run that process, we get the listing in standard output, and then the process is over. If I do a git version the process runs, and then we quickly get the standard output and the process is over.

So if we have these processes that have small bits of data, they're perfect for execute. So spawn is made for longer, ongoing processes with large amounts of data, like our alwaysTalking. So notice this process doesn't just give us some data and immediately end, which means that execute is not the function that we want to use with this. So let's go ahead and go back into our files, and from our files you will notice that we have a spawn.js which is just an empty file.

What we're going to do this time is use the spawn function. So I'm going to create a variable for that function, and then I'm going to require our child process module. And I'm going to go ahead and pluck that spawn function out of there. So now I have my spawn function set up. This time I'm going to create a variable for the child process, and that will be returned by my spawn function. The first argument that I'm going to send to the spawn function is the command that I want to run in the terminal. That is node. The second argument is going to be an array of all of the things that I would run after the node command.

So in order to run the alwaysTalking app we will node alwaysTalking in the command line, so I'll just go ahead and put alwaysTalking or the options that would show up in the command line after node into an array, which represents the second argument of the spawn function. So with the child process instance I can listen for data events on the stdout object. So cp.stdout is the stdout object of the child process. Whenever we have a data event, this callback function will fire.

And this callback function will fire, and we will receive that data as an argument. So I'm just going to log that data. We'll go ahead and log that we received some data, stdout, and then we can actually log what that data is right here. Don't forget your last back-tick for that template string. There we go. Another thing we can do with the child process is we can listen for when they close. A close event will raised on the child process when it closes. When a close event is raised I'm going to invoke this callback function here.

So when our alwaysTalking process ends I'm just going to go ahead and log that that has ended. And I will also exit this process. So when our child process alwaysTalking ends, we will also end this process. Now we can send data to this child process instance using the standard input object, so let's go ahead and set a timeout. And this function will be invoked after about four seconds, so we'll set a timeout, we'll let our child process run for about four seconds, and then after four seconds I'm going to send some data to the child process.

And I'm going to go ahead and write stop. Any data that we send to the alwaysTalking application will cause it to stop the interval and also exit the application. So after about four seconds we should close that child process by sending it the stop command on the standard input. So I'm going to go ahead and save this, and let's go out to our terminal. And now we can run our app, and when we run this app we can see that we have started our alwaysTalking process. And whenever our alwaysTalking process writes data to standard output, we are receiving that data via our standard output listener.

Also when the child process ends, notice that we see STDIN Data Received -> stop. So we are able to send the stop command to our child process, and that has caused it to end, which causes our process to log Child Process has ended, and then our process ends. So we were able to spawn the alwaysTalking JavaScript file from our spawn.js file. Again you're going to use spawn for ongoing, longer processes with more data, and you can communicate with those processes via standard input and standard output.


*/